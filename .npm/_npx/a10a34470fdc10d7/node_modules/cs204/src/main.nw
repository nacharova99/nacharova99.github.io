\maketitle
Студент входит на сайт, используя учётную запись на github.
При первом входе для него создаётся репозиторий
для сохранения выполненных заданий и  результатов
тестирования заданий. После входа студент видит свои оценки, 
замечания преподавателя, результаты тестирования заданий.
Использование github репозиториев для сохранения результатов
даёт возможность преподавателю и студенту совместно работать с
выполняемыми заданиями, преподаватель и студент могут вносить изменения в
код, преподаватель может ставить задания перед студентом, через механизм issues, 
отслеживать историю развития проекта.
Описания действий при тестировании мы сохраняем 
в репозитории в формате JSON. 
В этой статье мы рассмотрим программу проводящую тестирование
и сохраняющую результат тестирования в репозитории.
Способ организации работы со студентами мы заимствовали 
из курсе информатики университета Гарварда https://cs50.harvrad.edu.  
Исходный код писали сами, и считаем, что всякий преподаватель
должен сам писать код своих инструментов, а не пользоваться готовыми
системами, например, moodle. Для написания статьи был выбран стиль
литературного программирования. Цель этого показать, как мы 
реализовали наши инструменты, чтобы другие преподаватели
могли использовать наш опыт при создании своих, 
мы считаем, что преподаватель должен сам создавать
инструменты для автоматизации работы со студентами а не брать готовые. 

\section{Анализ задания}
Цель программы проверить работу студента и загрузить её
вместе с результатом тестирования в репозиторий на github. 

\subsection{Описание проверки}
Описание проверки сохраняем в репозитории 
[[https://github.com/{orgTest}/psets]].
Например, для задний на 2021 года создаём ветку 2021,
для каждого задания создаём в ней файл. Ниже приведён 
пример файла [[hello.js]] .
Структура файла:

[[{ "files":["hello.js"], "output":"Hello, World!", "run": "node hello.js"}]]
Свойство files содержит список файлов, отправляемых на проверку.
Свойство output содержит ожидаемый вывод из программы.
Свойство run содержит команду запуска.

\subsection{Запуск программы}
Для запуска программы переходим в терминале в каталог
с заданием и выполняем команду, например,
[[check204 2021/hello]]
Аргумент -- имя ветки и название задания (имя файла без расширения).


\section{Структура}
<<check204.js>>=
#!/usr/bin/env node
<<загрузка модулей>>
<<константы>>
<<функции>>
;(async function main()
{
	<<проверка аргументов командной строки>>
	<<закачивание описания>>
	<<тестирование задания>>
	if(local)
		process.exit(0);
	<<отправка на проверку>>
})()
@ 

\section{Реализация}
\subsection{Проверка аргументов}
Если пользователь не указал ветку и название задания, 
то выдаётся сообщение об ошибке.
Если пользователь указал неверный адрес, то выдаётся сообщение об ошибке.
<<проверка аргументов командной строки>>=
await checkArgs();
@

<<реализация проверки аргументов>>=
async function checkArgs() 
{
	if(process.argv.length < 3 || process.argv.length > 4)
	{
		console.log(chalk.red(`Использование: \n 
			check204 branch/problem \n
			или\n
			check204 branch/problem local\n`));
		process.exit(1); 
	}
	const url2 = `https://raw.githubusercontent.com/${orgTest}/psets/${process.argv[2]}.json`;
	const url_exist = await urlExist(url2);
	if(!url_exist)
	{
		console.log(chalk.red("Неверный адрес задания"));
		process.exit(2);
	}
	if(process.argv.length == 4)
	{
		if(process.argv[3] == 'local')
			local = true;
		else
		{
			console.log(`Испольлзование: \n
				check204 branch/problem local\n`)
			process.exit(2);
		}
	}
		
};

@ 

\subsection{Закачивание описания}
<<закачивание описания>>=
	const psetName = process.argv[2];
	const test = await getTask(psetName); 
@

<<реализация закачивания описания>>=
async function getTask(psetName)
{
	try
	{
	const url2 = `https://raw.githubusercontent.com/${orgTest}/psets/${psetName}.json` 
	const res = await fetch(url2, 
	{ 
		headers: 
		{ 
			"Accept": "application/json"
		 }
	})
	const res1 = await res.json();
	return res1;
	}catch(err)
	{
		console.log(err);
	}
};
@ 

\subsection{Тестирование программы}
<<тестирование задания>>=
	<<проверка наличия файлов>>
	<<проверка правильности вывода из программы>>
@ 

\subsubsection{Проверка наличия файлов}
<<проверка наличия файлов>>=
	await filesExists(test);
@

<<реализация проверки наличия файлов>>=
async function filesExists(test)
{
	const files = await readdir(process.cwd());
	for(const file of test.files)
	{
		if(files.includes(file)) 
		{
			console.log(chalk.green(`Файл ${file} присутствует.`));
			resTest += `Файл ${file} присутствует.\n`;
		}
				
		else
		{
			console.log(chalk.red(`Файл ${file} отсутствует.`)) 
			process.exit(1)
		}

	}
}
@ 

\subsubsection{Тест вывода из программы}
<<проверка правильности вывода из программы>>=
	await testOutput(test);
@


<<реализация проверки правильности вывода из программы>>=
async function testOutput(test)
{
	const { stdout, stderr } = await exec(`${test.run}`);
	if(!stdout.localeCompare(test.output))
	{
		console.log(chalk.green('Вывод из программы верный'));
		resTest +='# Вывод из программы верный\n';
	}
	else
	{
		console.log(chalk.red('Ошибка'));
		resTest += "# Ошибка\n";
		console.log(chalk.red('Программа выдаёт'));
		resTest += '# Программа выдаёт\n';
		resTest += '<pre>\n';
		resTest += stdout.toString();
		resTest += '</pre>\n';
		console.log(stdout);
		console.log(stderr);
		console.log(chalk.red('Правильный вывод'));
		resTest += '# Правильный вывод\n';
		resTest += "<pre>";
		resTest += test.output;
		resTest += "</pre>"
		console.log(test.output);
		console.log(stderr);
	}
}
@ 


\subsection{Отправка на проверку}

<<отправка на проверку>>=
	<<создание временного каталога>>
	<<клонирование каталога>>
@ 

\subsubsection{Создание временного каталога}

<<создание временного каталога>>=
	await createDir(test);
@

<<реализация создания временного каталога>>=
async function createDir(test)
{
	await rm('/tmp/test', {force: true, recursive: true}); 
	console.log("Folder /tmp/test deleted");
	await mkdir('/tmp/test', {recursive: true}); 
	console.log("Folder create dir");
}
@ 

\subsubsection{Клонирование каталога}
<<клонирование каталога>>=
	await cloneRepo(orgTest, psetName, test);
@

<<реализация клонирования каталога>>=
async function cloneRepo(org, psetName, test)
{
	try{
	var username = readlineSync.question('Github username:');
	const origin =`git@github.com:${org}/${username}.git`;
	// const origin = `https://${username}@github.com/${org}/${username}`;
	const {stdout, stderr} = await exec(`git clone ${origin} -b main /tmp/test`);
	console.log(stdout);
	console.log(stderr);
	await exec(`git checkout -b ${psetName}`, {cwd:'/tmp/test'})
	for(let file of test.files)
	{
		await copyFile(path.join(process.cwd(), file), path.join('/tmp/test', file));
	} 
	const fileName = `/tmp/test/${psetName.split('/')[1]}.md`;
	console.log(fileName);
	await writeFile(fileName,  resTest);
	await exec(`git config user.name test && git config user.email test && git add . && git commit -m test`, {cwd: '/tmp/test'});
	await exec(`git push -f ${origin} ${psetName}`, {cwd: '/tmp/test'}); 
	}catch(error)
	{
		console.error(error)
	}
}
@ 


\subsection{Загрузка модулей}

<<загрузка модулей>>=
import chalk from 'chalk';
import urlExist from 'url-exists-nodejs';
import fetch from 'node-fetch';
import {readdir, rm, mkdir, copyFile, writeFile } from 'node:fs/promises';
import readlineSync from 'readline-sync';
import * as child from 'node:child_process';
import * as util from 'node:util';
const exec = util.promisify(child.exec);
import * as path from 'node:path';
@ 


\subsection{Задание констант}
orgTest - имя организации в которой репозиторий 
описания задания. orgCheck - имя организации где сохраняем 
результат.
<<константы>>=
const orgTest = 'cs204';
const orgCheck = 'cs204check';
var resTest = '';
var local = false;
@ 

\section{Установка в домашний каталог}
Настроим на установку в каталог ~/npm.
<<установка>>=
mkdir ~/npm
npm config set prefix ~/npm
export PATH="$HOME/npm/bin:PATH"
@ 
Последняя строчка в [[.profile]], чтобы система находила программы.
Перезагрузить.
<<установка>>=
npm --global install check204
@ 


\subsection{Функции}
<<функции>>=
<<реализация проверки аргументов>>
<<реализация закачивания описания>>
<<реализация проверки наличия файлов>>
<<реализация проверки правильности вывода из программы>>
<<реализация создания временного каталога>>
<<реализация клонирования каталога>>
@

